# Why is Java so Popular? #
Two main reasons for popularity of Java are 
1. Platform Independence
2. Object Oriented Language
We will look at these in detail in later sections.

**What is Platform Independence?**
- Platform Independence is also called build once, run anywhere. Java is one of the most popular platform independent languages. Once we compile a java program and build a jar, we can run the jar (compiled java program) in any Operating System - where a JVM is installed.
- Java achieves Platform Independence in a beautiful way. On compiling a java file the output is a class file - which contains an internal java representation called bytecode. JVM converts bytecode to executable instructions. The executable instructions are different in different operating systems. So, there are different JVM's for different operating systems. A JVM for windows is different from a JVM for mac.However, both the JVM's understand the bytecode and convert it to the executable code for the respective operating system.
 
# What is ByteCode? #
Java bytecode is the instruction set of the Java virtual machine. Each bytecode is composed of one, or in some cases two bytes that represent the instruction (opcode), along with zero or more bytes for passing parameters.
Byte Code can be defined as an intermediate code generated by the compiler after the compilation of source code(JAVA Program). This intermediate code makes Java a platform-independent language.

# Compare JDK vs JVM VS JRE #
 
1. **JVM** : It's just the engine that translates Java bytecode (compiled by the JDK) into machine code for execution. Virtual machine that run the Java bytecode.Makes java portable.
Components:
•	Class loader: Loads class files.
•	Bytecode verifier: Verifies that the bytecode is valid and safe to execute.
•	Execution engine: Converts bytecode to machine code.
2. **JRE** : JRE is sufficient if you only need to run Java programs but not develop them. It's aimed at end-users who run Java applications. 
Components:
•	JVM (Java Virtual Machine)
•	Core Java libraries and classes
•	Supporting files for executing Java applications.
3. **JDK** : The JDK is essential when you need to write, compile, and debug Java code. It provides all the tools required for Java application development.
Components:
•	Java compiler (javac)
•	Java debugger (jdb)
•	JRE (which includes JVM and Java libraries)
•	Other tools like javap (class file disassembler) and jar (packaging tool).

# What are the important differences between C++ and Java? #
1. Java is platform independent. C++ is not platform independent.
2. Java & C++ are both NOT pure Object Oriented Languages. However, Java is more purer Object
Oriented Language (except for primitive variables). In C++, one can write structural programs
without using objects.
3. C++ has pointers (access to internal memory). Java has no concept called pointers.
4. In C++, programmer has to handle memory management. A programmer has to write code to
remove an object from memory. In Java, JVM takes care of removing objects from memory
using a process called Garbage Collection.
5. C++ supports Multiple Inheritance. Java does not support Multiple Inheritance.
6. 
# What is the role for a ClassLoader in Java? #
A Java program is made up of a number of custom classes (written by programmers like us) and core classes (which come pre-packaged with Java). When a program is executed, JVM needs to load the content of all the needed class. JVM uses a ClassLoader to find the classes.
Three Class Loaders are shown in the picture
• System Class Loader - Loads all classes from CLASSPATH. 
More about classpath and buildpath is explained in https://www.baeldung.com/java-classpath-vs-build-path. 
• Extension Class Loader - Loads all classes from extension directory. The extension class loader loads from the JDK extensions directory, usually the $JAVA_HOME/lib/ext directory, or any other directory mentioned in the java.ext.dirs system property.
• Bootstrap Class Loader - Loads all the Java core files. It’s mainly responsible for loading JDK internal classes, typically rt.jar and other core libraries located in the $JAVA_HOME/jre/lib directory. Additionally, the Bootstrap class loader serves as the parent of all the other ClassLoader instances.
When JVM needs to find a class, it starts with System Class Loader. If it is not found, it checks with
Extension Class Loader. If it not found, it goes to the Bootstrap Class Loader. If a class is still not found, a ClassNotFoundException is thrown.

# What is difference between classpath and build path? #
1. Overview
In this tutorial, we will explore the key difference between classpath and build path in Java. While both classpath and build path are essential for compiling and running Java code, they serve distinct purposes.
2. Classpath
The classpath is an environment variable used by the Java Virtual Machine (JVM) to locate and load classes when running a Java program. It specifies a list of directories, JAR files, and ZIP files where the JVM should look to find and load class files.
We can set the classpath from the command line or in an integrated development environment (IDE).
2.1. Setting the Classpath via the Command Line
To set the classpath via the command line, we use the -classpath option when running the java command:
java -classpath /path/to/class/files MyProgram
Copy
Here, MyProgram is the name of the main class, and /path/to/class/files is the directory where the class file is located. If we have multiple directories and/or JAR files, we can separate them using a colon:
java -classpath /path/to/classes:/path/to/lib.jar MyProgram
Copy
2.2. Setting the Classpath in an IDE
Most IDEs have built-in support for setting the classpath. Let’s check the steps for doing so in two popular IDEs — Eclipse and IntelliJ IDEA.
In Eclipse:
•	Right-click on the project
•	Select Build Path
•	Click on Configure Build Path
•	Add directories and JAR files under the Libraries tab
In IntelliJ IDEA:
•	Left-click on File from the menu
•	Select Project Structure
•	Navigate to Modules
•	Click on Dependencies
•	Click on + at the bottom of the dialog
•	Add directories and JAR files and click on the Ok button
3. Build Path
The build path is a list of all the resources that are required to build a Java project, including source files, class files, libraries, and other dependencies. The Java development environment such as Eclipse, IntelliJ IDEA, or NetBeans uses the build path to compile and build the Java project.
The build path can be set in the project directories of both Eclipse and IntelliJ IDEA. Let’s see how to set the build path in each IDE.
In Eclipse:
•	Go to Project Properties by right-clicking on the project and selecting Properties
•	Navigate to Java Build Path
•	Click on the Libraries tab
•	Add the required libraries and click on the Ok button
In IntelliJ IDEA:
•	Left-click on File from the menu
•	Select Modules
•	Navigate to Dependencies
•	Click on + at the bottom of the dialog
•	Add directories and click on the Ok button

# Differences Between Classpath and Build Path #
Finally, let’s explore the main difference between Classpath and Build path. While the JVM uses the classpath at runtime to find class files and libraries, IDEs use the build path during the build process to find dependencies.
Here’s a quick comparison between JVM usage of the Class path and IDEs’ usage of the Build path:
	Classpath	Build Path
Usage	JVM at runtime to find files	IDEs during the build process
Set up	Command line/environment	In the IDE
Purpose	Find class files and libraries	Find dependencies
It’s worth noting that the classpath is not used only at runtime but also at build-time for different build phases, like compilation and testing. The build system uses the classpath to locate and load classes and libraries required for the build process.
Both Classpath and Build Path are essential for the successful execution and building of a Java program. If either path is not set up correctly, errors can occur, and the program will fail to execute or build correctly.
5. Conclusion
Understanding the differences between classpath and build path is crucial for correctly setting up a Java environment. While the classpath is used by the JVM to find class files and libraries at runtime, the build path is used by IDEs during the build process to find dependencies. Both classpath and build path are essential for the successful execution and building of a Java program.

# What is difference between building and compiling in Java? #
https://stackoverflow.com/questions/2650168/building-vs-compiling-java
The "Build" is a process that covers all the steps required to create a "deliverable" of your software. In the Java world, this typically includes:
1.	Generating sources (sometimes).
2.	Compiling sources.
3.	Compiling test sources.
4.	Executing tests (unit tests, integration tests, etc).
5.	Packaging (into jar, war, ejb-jar, ear).
6.	Running health checks (static analyzers like Checkstyle, Findbugs, PMD, test coverage, etc).
7.	Generating reports.
So as you can see, compiling is only a (small) part of the build (and the best practice is to fully automate all the steps with tools like Maven or Ant and to run the build continuously

# Wrapper Classes #



}


 




# Interface

- An interface defines a contract for responsibilities (methods) of a class.
- It is a way to specify a contract for what a class must do, without dictating how it should do it.
- Example in Java api : Map interface, Collection interface.
- An interface is declared by using the keyword interface. Look at the example below: Flyable is an
interface.

```java
interface InterfaceName {
    // Abstract method (implicitly public and abstract)
    void abstractMethod();
    
    // Default method (introduced in Java 8)
    default void defaultMethod() {
        System.out.println("This is a default method");
    }
    
    // Static method (introduced in Java 8)
    static void staticMethod() {
        System.out.println("This is a static method");
    }

    // Constant (implicitly public, static, final)
    int CONSTANT = 100;
}

```
- A class that implements an interface must provide concrete implementations for all the interface's abstract methods.

```java 
class MyClass implements InterfaceName {
    // Implementing abstract method
    @Override
    public void abstractMethod() {
        System.out.println("Implemented abstract method");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.abstractMethod();  // Output: Implemented abstract method
        
        // Calling default method
        obj.defaultMethod();  // Output: This is a default method
        
        // Calling static method (via interface name)
        InterfaceName.staticMethod();  // Output: This is a static method
    }
}
```
- Multiple Interfaces: A class can implement multiple interfaces, enabling multiple inheritance behavior:

```java 
class MyClass implements Interface1, Interface2 {
    // Must implement methods from both interfaces
}
```
- Variables in an interface are always public, static, final. Variables in an interface cannot be declared private.
- Interface methods are by default public and abstract. Before Java 8, A concrete method (fully defined method) cannot be created in an interface

```java
interface ExampleInterface1 {
//By default - public abstract. No other modifier allowed
void method1();//method1 is public and abstract
//private void method6();//COMPILER ERROR!
//This method, uncommented, would have given COMPILER ERROR!

//in Java 7. Allowed from Java 8.
default void method5() {
System.out .println("Method5");
}
}
```
- An interface can extend another interface. 
- An interface cannot extend a class.
- A class can implement multiple interfaces. It should implement all the method declared in all Interfaces being implemented.
```java
public class HashMap<K,V> extends AbstractMap<K,V>
implements Map<K,V>, Cloneable, Serializable
```
- Interfaces cannot have constructors because they cannot be instantiated directly.
- An interface cannot contain instance fields, only constants (public static final).
- **Default Methods** (Java 8 and later): An interface can have default methods, which are methods with a body. These allow interfaces to provide default behavior without forcing implementing classes to override them.
- **Static methods** (Java 8 and later): Interfaces can also have static methods, which can be called on the interface itself rather than on an instance of the class.

# Abstract class

- An abstract class is a class that cannot be instantiated, but must be inherited from. An abstract class may be fully implemented, but is more usually partially implemented or not implemented at all, thereby encapsulating common functionality for inherited classes.
 ```java
 bstract class Animal {  // Abstract class
    // Abstract method (no implementation)
    public abstract void sound();

    // Concrete method (has an implementation)
    public void sleep() {
        System.out.println("This animal is sleeping.");
    }
}

class Dog extends Animal {  // Concrete subclass of Animal
    // Implementing the abstract method
    public void sound() {
        System.out.println("Woof Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();  // Creating an object of Dog
        myDog.sound();  // Output: Woof Woof!
        myDog.sleep();  // Output: This animal is sleeping.
    }
}
```
- If you want to provide common, implemented functionality among all implementations of your
component, use an abstract class. Abstract classes allow you to partially implement your class.
- An example of an abstract class in the JDK is **AbstractMap**, which is part of the Collections
Framework. Its subclasses (which include **HashMap**, **TreeMap**, and **ConcurrentHashMap**) share
many methods (including **get**, **put**, **isEmpty**, **containsKey**, and **containsValue**) that AbstractMap defines.
- Example abstract method : *public abstract Set> entrySet()*;
- Consider using abstract classes and inheritance when our problem makes the evidence “A is a B”. For example, “Dog is an Animal”, “Lamborghini is a Car”, etc.

# When do you use an interface? #
- If the problem needs to be solved using multiple inheritances and is composed of different class hierarchies.
- When unrelated classes implement our interface. For example, Comparable provides the compareTo() method that can be overridden to compare two objects.
- Consider using the interface when our problem makes the statement “A is capable of [doing this]”. For example, “Clonable is capable of cloning an object”, “Drawable is capable of drawing a shape”, etc.

# Modifiers #
What is default class modifier?
- A class is called a Default Class is when there is no access modifier specified on a class.
- Default classes are visible inside the same package only.
- Default access is also called Package access.
Example
```java
package com.rithus.classmodifiers.defaultaccess.a;
/* No public before class. So this class has default access*/
class DefaultAccessClass {
//Default access is also called package access
}
```
Another Class in Same Package: Has access to default class
```java
package com.rithus.classmodifiers.defaultaccess.a;
public class AnotherClassInSamePackage {
//DefaultAccessClass and AnotherClassInSamePackage
//are in same package.
//So, DefaultAccessClass is visible.
//An instance of the class can be created.
DefaultAccessClass defaultAccess;
}
```
Class in Different Package: NO access to default class
```java
package com.rithus.classmodifiers.defaultaccess.b;
public class ClassInDifferentPackage {
//Class DefaultAccessClass and Class ClassInDifferentPackage
//are in different packages (*.a and *.b)
//So, DefaultAccessClass is not visible to ClassInDifferentPackage
//Below line of code will cause compilation error if uncommented
//DefaultAccessClass defaultAccess; //COMPILE ERROR!!
}
```
## What is private access modifier? ##
- Private variables and methods can be accessed only in the class they are declared.
- Private variables and methods from SuperClass are NOT available in SubClass.

## What is default or package access modifier? ##
a. Default variables and methods can be accessed in the same package Classes.
b. Default variables and methods from SuperClass are available only to SubClasses in same package.

## What is protected access modifier? ##
a. Protected variables and methods can be accessed in the same package Classes.
b. Protected variables and methods from SuperClass are available to SubClass in any package

# What is public access modifier? ##
a. Public variables and methods can be accessed from every other Java classes.
b. Public variables and methods from SuperClass are all available directly in the SubClass

# What access types of variables can be accessed from a Class in Same Package? ##
Look at the code below to understand what can be accessed and what cannot be.
```java
package com.rithus.membermodifiers.access;
public class TestClassInSamePackage {
public static void main(String[] args) {
ExampleClass example = new ExampleClass();
example.publicVariable = 5;
example.publicMethod();
//privateVariable is not visible
//Below Line, uncommented, would give compiler error
//example.privateVariable=5; //COMPILE ERROR
//example.privateMethod();
example.protectedVariable = 5;
example.protectedMethod();
example.defaultVariable = 5;
example.defaultMethod();
}
}
```
## What access types of variables can be accessed from a Class in Different Package? ##
Look at the code below to understand what can be accessed and what cannot be.
```java
package com.rithus.membermodifiers.access.different;
import com.rithus.membermodifiers.access.ExampleClass;
public class TestClassInDifferentPackage {
public static void main(String[] args) {
ExampleClass example = new ExampleClass();
example.publicVariable = 5;
example.publicMethod();
//privateVariable,privateMethod are not visible
//Below Lines, uncommented, would give compiler error
//example.privateVariable=5; //COMPILE ERROR
//example.privateMethod();//COMPILE ERROR
//protectedVariable,protectedMethod are not visible
//Below Lines, uncommented, would give compiler error
//example.protectedVariable = 5; //COMPILE ERROR
//example.protectedMethod();//COMPILE ERROR
//defaultVariable,defaultMethod are not visible
//Below Lines, uncommented, would give compiler error
//example.defaultVariable = 5;//COMPILE ERROR
//example.defaultMethod();//COMPILE ERROR
}
}
```
## What access types of variables can be accessed from a Sub Class in Same Package? ##
Look at the code below to understand what can be accessed and what cannot be.
```java
package com.rithus.membermodifiers.access;
public class SubClassInSamePackage extends ExampleClass {
void subClassMethod(){
publicVariable = 5;
publicMethod();
//privateVariable is not visible to SubClass
//Below Line, uncommented, would give compiler error
//privateVariable=5; //COMPILE ERROR
//privateMethod();
protectedVariable = 5;
protectedMethod();
defaultVariable = 5;
defaultMethod();
}
}
```
## What access types of variables can be accessed from a Sub Class in Different Package? ##
Look at the code below to understand what can be accessed and what cannot be.
```java
package com.rithus.membermodifiers.access.different;
import com.rithus.membermodifiers.access.ExampleClass;
public class SubClassInDifferentPackage extends ExampleClass {
void subClassMethod(){
publicVariable = 5;
publicMethod();
//privateVariable is not visible to SubClass
//Below Line, uncommented, would give compiler error
//privateVariable=5; //COMPILE ERROR
//privateMethod();
protectedVariable = 5;
protectedMethod();
//privateVariable is not visible to SubClass
//Below Line, uncommented, would give compiler error
//defaultVariable = 5; //COMPILE ERROR
//defaultMethod();
}
}
```
## What is the use of a final modifier on a class? ##
Final class cannot be extended. Example of Final class in Java is the String class. Final is used very
rarely as it prevents re-use of the class.Consider the class below which is declared as final.
Final Class examples : String, Integer, Double and other wrapper classes
```java
final public class FinalClass {
}
Below class will not compile if uncommented. FinalClass cannot be extended.
/*
class ExtendingFinalClass extends FinalClass{ //COMPILER ERROR
}
*/
```
## What is the use of a final modifier on a method? ##
Final methods cannot be overridden. Consider the class FinalMemberModifiersExample with method finalMethod which is declared as final.
public class FinalMemberModifiersExample {
final void finalMethod(){
}
}
Any SubClass extending above class cannot override the finalMethod().
```java
class SubClass extends FinalMemberModifiersExample {
//final method cannot be over-riddent
//Below method, uncommented, causes compilation Error
/*
final void finalMethod(){
}
*/
}
```
## What is a Final variable? ##
Once initialized, the value of a final variable cannot be changed.
```java
final int finalValue = 5;
//finalValue = 10; //COMPILER ERROR
Final Variable example : java.lang.Math.PI
What is a final argument?
Final arguments value cannot be modified. Consider the example below:
void testMethod(final int finalArgument){
//final argument cannot be modified
//Below line, uncommented, causes compilation Error
//finalArgument = 5;//COMPILER ERROR
}
```
## What happens when a variable is marked as volatile? ##
• Volatile can only be applied to instance variables.
• A volatile variable is one whose value is always written to and read from "main memory". Each
thread has its own cache in Java. The volatile variable will not be stored on a Thread cache.
## What is a Static Variable? ##
Static variables and methods are class level variables and methods. There is only one copy of the static variable for the entire Class. Each instance of the Class (object) will NOT have a unique copy of a static variable. Let’s start with a real world example of a Class with static variable and methods.
Static Variable/Method – Example
count variable in Cricketer class is static. The method to get the count value getCount() is also a static method.
```java
public class Cricketer {
private static int count;
public Cricketer() {
count++;
}
static int getCount() {
return count;
}
public static void main(String[] args) {
Cricketer cricketer1 = new Cricketer();
Cricketer cricketer2 = new Cricketer();
Cricketer cricketer3 = new Cricketer();
Cricketer cricketer4 = new Cricketer();
System.out.println(Cricketer.getCount());//4
}
}
```
4 instances of the Cricketer class are created. Variable count is incremented with every instance created in the constructor.

